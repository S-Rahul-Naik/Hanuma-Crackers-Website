const Order = require('../models/Order');
const Product = require('../models/Product');
const User = require('../models/User');
const emailService = require('../utils/emailService');
const logger = require('../utils/logger');

// @desc    Create new order
// @route   POST /api/orders
// @access  Private
exports.createOrder = async (req, res, next) => {
  try {
    const {
      items,
      shippingAddress,
      paymentMethod,
      itemsPrice,
      taxPrice,
      shippingPrice,
      totalPrice
    } = req.body;

    if (!items || items.length === 0) {
      return res.status(400).json({
        success: false,
        message: 'No order items'
      });
    }

    // Verify products exist and have sufficient stock
    for (const item of items) {
      const product = await Product.findById(item.product);
      if (!product) {
        return res.status(404).json({
          success: false,
          message: `Product not found: ${item.name}`
        });
      }
      if (product.stock < item.quantity) {
        return res.status(400).json({
          success: false,
          message: `Insufficient stock for ${product.name}. Available: ${product.stock}`
        });
      }
    }

    // Create order; orderNumber will be auto-generated by pre-save hook. Provide a fallback if missing.
    let order = await Order.create({
      user: req.user._id,
      items,
      shippingAddress,
      paymentMethod,
      itemsPrice,
      taxPrice,
      shippingPrice,
      totalPrice
    });
    if (!order.orderNumber) {
      const count = await Order.countDocuments();
      order.orderNumber = `ORD-${String(count + 1).padStart(6, '0')}`;
      await order.save();
    }

    // Update product stock
    for (const item of items) {
      await Product.findByIdAndUpdate(
        item.product,
        {
          $inc: { 
            stock: -item.quantity,
            totalSales: item.quantity
          }
        }
      );
    }

    // Update user stats
    await User.findByIdAndUpdate(
      req.user._id,
      {
        $inc: { 
          totalOrders: 1,
          totalSpent: totalPrice
        },
        lastOrderDate: new Date()
      }
    );

    // Calculate estimated delivery
    order.calculateEstimatedDelivery();
    await order.save();

    const populatedOrder = await Order.findById(order._id)
      .populate('user', 'name email phone')
      .populate('items.product', 'name price images');

    // Send order confirmation emails asynchronously
    setImmediate(async () => {
      try {
        // Send order confirmation to customer
        await emailService.sendOrderConfirmation(populatedOrder, populatedOrder.user.email);
        
        // Send new order notification to admin
        await emailService.sendNewOrderNotificationToAdmin(populatedOrder);
        
        logger.info('Order confirmation emails sent successfully', {
          orderId: order._id,
          orderNumber: order.orderNumber,
          customerEmail: populatedOrder.user.email
        });
      } catch (emailError) {
        logger.error('Failed to send order confirmation emails:', {
          error: emailError.message,
          orderId: order._id,
          orderNumber: order.orderNumber
        });
      }
    });

    res.status(201).json({
      success: true,
      order: populatedOrder
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Get logged in user orders
// @route   GET /api/orders/myorders
// @access  Private
exports.getMyOrders = async (req, res, next) => {
  try {
    // Exclude draft orders from user dashboard
    const orders = await Order.find({ 
      user: req.user._id,
      status: { $ne: 'draft' } // Exclude draft orders
    })
      .populate('items.product', 'name price images')
      .sort('-createdAt');

    res.status(200).json({
      success: true,
      count: orders.length,
      orders
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Get order by ID
// @route   GET /api/orders/:id
// @access  Private
exports.getOrder = async (req, res, next) => {
  try {
    const order = await Order.findById(req.params.id)
      .populate('user', 'name email phone')
      .populate('items.product', 'name price images');

    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'Order not found'
      });
    }

    // Make sure user owns order or is admin
    if (order.user._id.toString() !== req.user._id.toString() && req.user.role !== 'admin') {
      return res.status(401).json({
        success: false,
        message: 'Not authorized to access this order'
      });
    }

    res.status(200).json({
      success: true,
      order
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Cancel order
// @route   PUT /api/orders/:id/cancel
// @access  Private
exports.cancelOrder = async (req, res, next) => {
  try {
    const order = await Order.findById(req.params.id);

    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'Order not found'
      });
    }

    // Make sure user owns order or is admin
    if (order.user.toString() !== req.user._id.toString() && req.user.role !== 'admin') {
      return res.status(401).json({
        success: false,
        message: 'Not authorized to cancel this order'
      });
    }

    if (!order.canBeCancelled()) {
      return res.status(400).json({
        success: false,
        message: 'Cannot cancel order in current status'
      });
    }

    // Restore product stock
    for (const item of order.items) {
      await Product.findByIdAndUpdate(
        item.product,
        {
          $inc: { 
            stock: item.quantity,
            totalSales: -item.quantity
          }
        }
      );
    }

    // Store cancellation details
    order.status = 'cancelled';
    order.cancellationReason = req.body.reason;
    order.cancellationComment = req.body.comment;
    order.cancelledAt = new Date();
    
    await order.save();

    res.status(200).json({
      success: true,
      order
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Request refund for order
// @route   PUT /api/orders/:id/refund
// @access  Private
exports.requestRefund = async (req, res, next) => {
  try {
    const order = await Order.findById(req.params.id);

    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'Order not found'
      });
    }

    // Make sure user owns order or is admin
    if (order.user.toString() !== req.user._id.toString() && req.user.role !== 'admin') {
      return res.status(401).json({
        success: false,
        message: 'Not authorized to request refund for this order'
      });
    }

    // Check if refund can be requested
    if (order.status === 'refunded') {
      return res.status(400).json({
        success: false,
        message: 'This order has already been refunded'
      });
    }

    // Allow refund for any status except refunded (more flexible than before)
    // if (order.paymentStatus !== 'paid') {
    //   return res.status(400).json({
    //     success: false,
    //     message: 'Refund can only be requested for paid orders'
    //   });
    // }

    // Check if refund already requested
    if (order.refundStatus && order.refundStatus !== 'none') {
      return res.status(400).json({
        success: false,
        message: 'Refund has already been requested for this order'
      });
    }

    // Store refund request details
    order.refundStatus = 'requested';
    order.refundReason = req.body.reason;
    order.refundComment = req.body.comment;
    order.refundRequestedAt = new Date();
    
    await order.save();

    // Create admin notification for refund request
    const adminNotification = {
      type: 'refund_request',
      orderId: order._id,
      orderNumber: order.orderNumber,
      customerName: req.user.name,
      customerEmail: req.user.email,
      amount: order.totalPrice,
      reason: req.body.reason,
      comment: req.body.comment,
      requestedAt: new Date()
    };

    // Log for admin (in production, this would be saved to database or sent via email)
    console.log('=== ADMIN NOTIFICATION: REFUND REQUEST ===');
    console.log(`Order: ${order.orderNumber}`);
    console.log(`Customer: ${req.user.name} (${req.user.email})`);
    console.log(`Amount: â‚¹${order.totalPrice}`);
    console.log(`Reason: ${req.body.reason}`);
    console.log(`Comment: ${req.body.comment}`);
    console.log(`Status: ${order.status}`);
    console.log('==========================================');

    res.status(200).json({
      success: true,
      message: 'Refund request submitted successfully. Admin will review your request.',
      order
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Get all orders (Admin)
// @route   GET /api/orders
// @access  Private/Admin
exports.getOrders = async (req, res, next) => {
  try {
    const page = parseInt(req.query.page, 10) || 1;
    const limit = parseInt(req.query.limit, 10) || 10;
    const startIndex = (page - 1) * limit;

    // Exclude draft orders from admin view
    const filterQuery = { status: { $ne: 'draft' } };
    const total = await Order.countDocuments(filterQuery);
    const orders = await Order.find(filterQuery)
      .populate('user', 'name email phone')
      .populate('items.product', 'name price')
      .sort('-createdAt')
      .skip(startIndex)
      .limit(limit);

    // Pagination result
    const pagination = {};
    if ((startIndex + limit) < total) {
      pagination.next = { page: page + 1, limit };
    }
    if (startIndex > 0) {
      pagination.prev = { page: page - 1, limit };
    }

    res.status(200).json({
      success: true,
      count: orders.length,
      total,
      pagination,
      orders
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Update order status (Admin)
// @route   PUT /api/orders/:id/status
// @access  Private/Admin
exports.updateOrderStatus = async (req, res, next) => {
  try {
    const { status, trackingNumber, notes } = req.body;

    const order = await Order.findById(req.params.id);

    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'Order not found'
      });
    }

    order.status = status;
    if (trackingNumber) order.trackingNumber = trackingNumber;
    if (notes) order.notes = notes;

    if (status === 'delivered') {
      order.actualDeliveryDate = new Date();
    }

    await order.save();

    const updatedOrder = await Order.findById(order._id)
      .populate('user', 'name email phone')
      .populate('items.product', 'name price');

    res.status(200).json({
      success: true,
      order: updatedOrder
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Get order statistics (Admin)
// @route   GET /api/orders/stats
// @access  Private/Admin
exports.getOrderStats = async (req, res, next) => {
  try {
    // Exclude draft orders from all statistics
    const totalOrders = await Order.countDocuments({ status: { $ne: 'draft' } });
    const pendingOrders = await Order.countDocuments({ status: 'pending' });
    const processingOrders = await Order.countDocuments({ status: 'processing' });
    const shippedOrders = await Order.countDocuments({ status: 'shipped' });
    const deliveredOrders = await Order.countDocuments({ status: 'delivered' });
    const cancelledOrders = await Order.countDocuments({ status: 'cancelled' });

    // Revenue calculation - exclude draft and cancelled orders
    const revenueStats = await Order.aggregate([
      { $match: { 
        status: { $nin: ['cancelled', 'draft'] } 
      }},
      {
        $group: {
          _id: null,
          totalRevenue: { $sum: '$totalPrice' },
          averageOrderValue: { $avg: '$totalPrice' }
        }
      }
    ]);

    // Monthly revenue - exclude draft and cancelled orders
    const monthlyRevenue = await Order.aggregate([
      {
        $match: {
          status: { $nin: ['cancelled', 'draft'] },
          createdAt: { $gte: new Date(Date.now() - 6 * 30 * 24 * 60 * 60 * 1000) }
        }
      },
      {
        $group: {
          _id: {
            year: { $year: '$createdAt' },
            month: { $month: '$createdAt' }
          },
          revenue: { $sum: '$totalPrice' },
          orders: { $sum: 1 }
        }
      },
      { $sort: { '_id.year': 1, '_id.month': 1 } }
    ]);

    res.status(200).json({
      success: true,
      stats: {
        totalOrders,
        pendingOrders,
        processingOrders,
        shippedOrders,
        deliveredOrders,
        cancelledOrders,
        totalRevenue: revenueStats[0]?.totalRevenue || 0,
        averageOrderValue: revenueStats[0]?.averageOrderValue || 0,
        monthlyRevenue
      }
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Upload payment receipt for order
// @route   POST /api/orders/upload-receipt
// @access  Private
exports.uploadPaymentReceipt = async (req, res, next) => {
  try {
    const { orderId, orderNumber } = req.body;

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'Please upload a payment receipt image'
      });
    }

    if (!orderId && !orderNumber) {
      return res.status(400).json({
        success: false,
        message: 'Order ID or Order Number is required'
      });
    }

    // Find the order
    let order;
    if (orderId) {
      order = await Order.findById(orderId);
    } else {
      order = await Order.findOne({ orderNumber });
    }

    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'Order not found'
      });
    }

    // Check if user owns this order
    if (order.user.toString() !== req.user._id.toString()) {
      return res.status(403).json({
        success: false,
        message: 'Not authorized to upload receipt for this order'
      });
    }

    // Upload to cloudinary
    const cloudinary = require('cloudinary').v2;
    const fileStr = `data:${req.file.mimetype};base64,${req.file.buffer.toString('base64')}`;

    const uploadResponse = await cloudinary.uploader.upload(fileStr, {
      folder: 'hanuma-crackers/payment-receipts',
      resource_type: 'image',
      transformation: [
        { width: 800, height: 600, crop: 'limit' },
        { quality: 'auto' },
        { format: 'auto' }
      ]
    });

    // Update order with receipt URL and change status
    order.paymentReceipt = uploadResponse.secure_url;
    order.paymentStatus = 'pending_verification';
    order.status = 'payment_verification';
    order.updatedAt = new Date();

    await order.save();

    res.status(200).json({
      success: true,
      message: 'Payment receipt uploaded successfully',
      order: {
        _id: order._id,
        orderNumber: order.orderNumber,
        paymentReceipt: order.paymentReceipt,
        paymentStatus: order.paymentStatus,
        status: order.status
      }
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Confirm draft order (make it visible in dashboards)
// @route   PUT /api/orders/:id/confirm
// @access  Private
exports.confirmOrder = async (req, res, next) => {
  try {
    const order = await Order.findById(req.params.id);

    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'Order not found'
      });
    }

    // Make sure user owns order
    if (order.user.toString() !== req.user._id.toString()) {
      return res.status(401).json({
        success: false,
        message: 'Not authorized to confirm this order'
      });
    }

    // Only confirm draft orders
    if (order.status !== 'draft') {
      return res.status(400).json({
        success: false,
        message: 'Order is already confirmed'
      });
    }

    // Update status from draft to pending
    order.status = 'pending';
    await order.save();

    res.status(200).json({
      success: true,
      message: 'Order confirmed successfully',
      order
    });
  } catch (error) {
    next(error);
  }
};

// @desc    Get refund requests (Admin)
// @route   GET /api/orders/refund-requests
// @access  Private/Admin
exports.getRefundRequests = async (req, res, next) => {
  try {
    const refundRequests = await Order.find({
      refundStatus: { $in: ['requested', 'approved', 'rejected', 'processed'] }
    })
    .populate('user', 'name email')
    .populate('items.product', 'name images')
    .sort({ refundRequestedAt: -1 });

    // Format the data for frontend
    const formattedRequests = refundRequests.map(order => ({
      _id: order._id,
      orderId: order._id,
      user: order.user,
      totalAmount: order.totalPrice,
      refundReason: order.refundReason,
      refundComment: order.refundComment,
      refundRequestedAt: order.refundRequestedAt,
      refundStatus: order.refundStatus,
      adminRefundComment: order.adminRefundComment,
      items: order.items
    }));

    res.status(200).json(formattedRequests);
  } catch (error) {
    next(error);
  }
};

// @desc    Process refund request (Admin)
// @route   PUT /api/orders/:id/process-refund
// @access  Private/Admin
exports.processRefund = async (req, res, next) => {
  try {
    const { action, adminComment } = req.body; // action: 'approve', 'reject', 'process'
    
    const order = await Order.findById(req.params.id);

    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'Order not found'
      });
    }

    if (order.refundStatus === 'none') {
      return res.status(400).json({
        success: false,
        message: 'No refund request found for this order'
      });
    }

    switch (action) {
      case 'approve':
        order.refundStatus = 'approved';
        break;
      case 'reject':
        order.refundStatus = 'rejected';
        break;
      case 'process':
        order.refundStatus = 'processed';
        order.refundProcessedAt = new Date();
        order.paymentStatus = 'refunded';
        break;
      default:
        return res.status(400).json({
          success: false,
          message: 'Invalid action. Use approve, reject, or process'
        });
    }

    order.adminRefundComment = adminComment;
    await order.save();

    res.status(200).json({
      success: true,
      message: `Refund request ${action}d successfully`,
      order
    });
  } catch (error) {
    next(error);
  }
};